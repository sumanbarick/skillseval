[
    {
        "q": "Which of the following unary operators can be overloaded?\ntrue\nfalse\n+\nnew\nis\n", 
        "options": [
            "1, 2, 3", 
            "3, 4, 5", 
            "3 only", 
            "5 only"
        ], 
        "ans": "A"
    }, 
    {
        "q": "A derived class can stop virtual inheritance by declaring an override as", 
        "options": [
            "inherits", 
            "extends", 
            "inheritable", 
            "not inheritable", 
            "sealed"
        ], 
        "ans": "E"
    }, 
    {
        "q": "Which of the following keyword is used to change the data and behavior of a base class by replacing a member of a base class with a new derived member?", 
        "options": [
            "new", 
            "base", 
            "overloads", 
            "override", 
            "overridable"
        ], 
        "ans": "A"
    }, 
    {
        "q": "Which of the following statements is correct?", 
        "options": [
            "When used as a modifier, the new keyword explicitly hides a member inherited from a base class.", 
            "Operator overloading works in different ways for structures and classes.", 
            "It is not necessary that all operator overloads are static methods of the class.", 
            "The cast operator can be overloaded."
        ], 
        "ans": "A"
    }, 
    {
        "q": "Which of the following keyword is used to overload user-defined types by defining static member functions?", 
        "options": [
            "op", 
            "opoverload", 
            "operator", 
            "operatoroverload", 
            "udoperator"
        ], 
        "ans": "C"
    }, 
    {
        "q": "Which of the followings is the correct way to overload + operator?", 
        "options": [
            "public sample operator + ( sample a, sample b )", 
            "public abstract operator + ( sample a, sample b)", 
            "public abstract sample operator + (sample a, sample b )", 
            "public static sample operator + ( sample a, sample b )", 
            "All of the above"
        ], 
        "ans": "D"
    }, 
    {
        "q": "Which of the following statements is correct?", 
        "options": [
            "Static methods can be a virtual method.", 
            "Abstract methods can be a virtual method.", 
            "It is necessary to override a virtual method.", 
            "When overriding a method, the names and type signatures of the override method must be the same as the virtual method that is being overriden.", 
            "We can override virtual as well as non-virtual methods."
        ], 
        "ans": "D"
    }, 
    {
        "q": "Which of the following statements are correct?\nAll operators in C#.NET can be overloaded.\nWe can use the new modifier to modify a nested type if the nested type is hiding another type.\nIn case of operator overloading all parameters must be of the different type than the class or struct that declares the operator.\nMethod overloading is used to create several methods with the same name that performs similar tasks on similar data types.\nOperator overloading permits the use of symbols to represent computations for a type.\n", 
        "options": [
            "1, 3", 
            "2, 4", 
            "2, 5", 
            "3, 4"
        ], 
        "ans": "C"
    }, 
    {
        "q": "Which of the following statement is correct about the C#.NET code snippet given below?\npublic class Sample\n{\n    public int x;\n    public virtual void fun()\n    { }\n}\npublic class DerivedSample : Sample\n{\n    new public void fun()\n    { }\n}", 
        "options": [
            "DerivedSample class hides the fun() method of base class.", 
            "The DerivedSample class version of fun() method gets called using Sample class reference which holds DerivedSample class object.", 
            "The code replaces the DerivedSample class version of fun() method with its Sample class version.", 
            "It is not possible to hide Sample class version of fun() method without use of new in DerivedSample class."
        ], 
        "ans": "A"
    }, 
    {
        "q": "Which of the following statements is correct?", 
        "options": [
            "The conditional logical operators cannot be overloaded.", 
            "When a binary operator is overloaded the corresponding assignment operator, if any, must be explicitly overloaded.", 
            "We can use the default equality operator in an overloaded implementation of the equality operator.", 
            "A public or nested public reference type does not overload the equality operator.", 
            "The array indexing operator can be overloaded."
        ], 
        "ans": "A"
    }, 
    {
        "q": "Which of the following operators cannot be overloaded?\ntrue\nfalse\nnew\n~\nsizeof\n", 
        "options": [
            "1, 3", 
            "2, 4", 
            "3, 5", 
            "All of the above"
        ], 
        "ans": "C"
    }, 
    {
        "q": "Which of the following modifier is used when a virtual method is redefined by a derived class?", 
        "options": [
            "overloads", 
            "override", 
            "overridable", 
            "virtual", 
            "base"
        ], 
        "ans": "B"
    }, 
    {
        "q": "In order for an instance of a derived class to completely take over a class member from a base class, the base class has to declare that member as", 
        "options": [
            "new", 
            "base", 
            "virtual", 
            "overrides", 
            "overloads"
        ], 
        "ans": "C"
    }, 
    {
        "q": "Which of the following can be declared as a virtual in a class?\nMethods\nProperties\nEvents\nFields\nStatic fields\n", 
        "options": [
            "1, 2, 3", 
            "3, 5", 
            "2, 4", 
            "2, 3, 5"
        ], 
        "ans": "A"
    }, 
    {
        "q": "Which of the following statements is correct?", 
        "options": [
            "Only one object can be created from an abstract class.", 
            "By default methods are virtual.", 
            "If a derived class does not provide its own version of virtual method then the one in the base class is used.", 
            "If the method in the derived class is not preceded by override keywords, the compiler will issue a warning and the method will behave as if the override keyword were present.", 
            "Each derived class does not have its own version of a virtual method."
        ], 
        "ans": "C"
    }, 
    {
        "q": "Which of the following are necessary for Run-time Polymorphism?\nThe overridden base method must be virtual, abstract or override.\nBoth the override method and the virtual method must have the same access level modifier.\nAn override declaration can change the accessibility of the virtual method.\nAn abstract inherited property cannot be overridden in a derived class.\nAn abstract method is implicitly a virtual method.\n", 
        "options": [
            "1, 3", 
            "1, 2, 5", 
            "2, 3, 4", 
            "4 only"
        ], 
        "ans": "B"
    }
]